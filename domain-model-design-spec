在成功划分了 **限界上下文 (Bounded Context)** 并定义了 **统一语言 (Ubiquitous Language)** 之后，学员将从战略设计正式转向 **战术设计**，即构建软件的核心——**领域模型（Domain Model）**。

下面是结合 DDD 战术模式提出的**设计领域模型的规范**，旨在指导学员构建出高内聚、低耦合、且业务规则清晰的模型。

---

## 领域模型设计规范（DDD 战术设计）

### 规范一：以聚合根（Aggregate Root）为核心建模

**核心原则：** **聚合** 是领域模型设计的基本单元。所有业务操作（命令）都应通过聚合根来协调和执行，以维护数据的一致性。

| 元素 | 规范要求 | 电商示例 |
| :--- | :--- | :--- |
| **聚合根的识别** | 必须识别出限界上下文内需要保证 **事务一致性** 的最小业务单元。 | 在 `订单上下文` 中，`Order` 是聚合根。 |
| **边界和引用** | 聚合内的所有实体和值对象只能通过**聚合根**访问。聚合之间引用只能通过 **ID**，**禁止直接的对象引用**。 | `Order` 聚合根包含 `LineItem`（实体），但引用 `Customer` 时，只能通过 `CustomerID`。 |
| **不变性 (Invariants)** | 聚合根必须负责执行和维护其内部所有业务规则（**不变性**）。 | 保证订单的总金额 (`TotalAmount`) 始终等于所有订单项 (`LineItem`) 金额之和。 |
| **命令入口** | 所有外部命令（例如：`AddItemToOrder`）必须通过聚合根的**公有方法**执行，并返回 **领域事件**。 | `Order.addItem(productId, quantity)`，而不是直接修改 `LineItem`。 |

### 规范二：区分领域对象类型

**核心原则：** 领域模型由三种核心类型组成：实体、值对象和领域服务，它们各有职责。

| 元素 | 规范要求 | 电商示例 |
| :--- | :--- | :--- |
| **实体 (Entity)** | 具有 **唯一标识符 (ID)** 和 **生命周期** 的对象。ID 必须在整个限界上下文内唯一。 | `Order`、`LineItem`（如果它在聚合内拥有独立 ID 和生命周期）、`Customer`。 |
| **值对象 (Value Object)** | 描述性对象，**没有唯一 ID**，由其属性定义。必须是 **不可变 (Immutable)** 的。 | `Money`（金额和货币类型）、`Address`（街道、城市、邮编）、`DiscountRate`。 |
| **领域服务 (Domain Service)** | 协调多个**聚合**或执行**无状态**的复杂业务逻辑（如计算、校验）时使用。**禁止**包含任何状态。 | `PricingService`：根据促销规则计算订单的最终价格。 |

### 规范三：严格遵守 DDD 分层架构

**核心原则：** 模型必须清晰地按照 DDD 的经典四层架构（或精简的三层架构）进行组织，确保关注点分离。

| 分层 | 规范要求 | 职责隔离 |
| :--- | :--- | :--- |
| **领域层 (Domain Layer)** | 包含所有核心业务逻辑（**聚合、实体、值对象、领域事件、领域服务**）。**禁止**依赖任何基础设施技术（如数据库、HTTP 客户端）。 | 领域模型**不能**包含 SQL 查询代码或 JSON 序列化逻辑。 |
| **应用层 (Application Layer)** | 协调领域层对象执行业务流程，处理事务和安全。**禁止**包含核心业务规则。 | `OrderApplicationService` 负责加载聚合、调用聚合方法、然后保存聚合。 |
| **基础设施层 (Infrastructure Layer)** | 负责技术实现细节，如数据持久化（**仓储实现**）、消息传递、外部 API 调用等。 | `OrderRepositoryImpl`（负责将 `Order` 聚合持久化到数据库）必须在这里。 |

### 规范四：领域事件（Domain Events）的使用

**核心原则：** 领域事件是 DDD 中解耦上下文和记录业务事实的关键。

| 元素 | 规范要求 | 电商示例 |
| :--- | :--- | :--- |
| **事件定义** | 事件必须是 **过去时** 的业务事实，仅包含**发生时**所需的数据（ID 和必要的快照数据）。 | `OrderCreated`、`PaymentFailed`、`StockReserved`。 |
| **事件发布** | 聚合根在执行完业务逻辑后，应 **发布** 相应的领域事件。 | `Order.place()` 方法执行完后，应生成 `OrderCreated` 事件。 |
| **用途** | 事件用于通知 **同一限界上下文内的策略**（同步）或通知 **其他限界上下文**（异步解耦）。 | `InventoryContext` 订阅 `OrderCreated` 事件来执行库存预留操作。 |

### 规范五：仓储（Repository）接口的定义

**核心原则：** 仓储是领域层与基础设施层之间的桥梁，它必须遵循**领域层**的语言。

| 元素 | 规范要求 | 职责隔离 |
| :--- | :--- | :--- |
| **定义位置** | 仓储接口 (`IOrderRepository`) 必须定义在 **领域层**。 | 确保领域模型不知道如何持久化自己。 |
| **实现位置** | 仓储接口的实现类 (`OrderRepositoryImpl`) 必须放在 **基础设施层**。 | 保证技术细节（JDBC, ORM, NoSQL）不会泄露到领域层。 |
| **方法签名** | 仓储方法应该操作整个**聚合根**，而不是单个字段或实体。 | `IOrderRepository.save(Order order)`，而不是 `IOrderRepository.updateOrderStatus(id, status)`。 |

通过遵循这些规范，学员将能够创建出健壮、可测试、且与业务领域紧密耦合的高质量软件模型。
